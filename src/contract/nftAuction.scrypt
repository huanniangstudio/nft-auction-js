import "nftAuctionProto.scrypt";
import "nftProto.scrypt";
import "rabinUtil.scrypt";

contract NftAuction {

  function checkData(bytes preScript,bytes script,int slen):bool{
      
      bytes senderAddress = NftAuctionProto.getSenderAddress(preScript,slen);
      int startBsvPrice = Util.fromLEUnsigned(NftAuctionProto.getStartBsvPrice(preScript,slen));
      bytes timeRabinPubKeyHash = NftAuctionProto.getTimeRabinPubkeyHash(preScript,slen);
      bytes nftCodeHash = NftAuctionProto.getNftCodehash(preScript,slen);
      bytes nftID = NftAuctionProto.getNftID(preScript,slen);
      int endTimeStamp = Util.fromLEUnsigned(NftAuctionProto.getEndTimestamp(preScript,slen));
      bytes rabinPubkeyHashArrayHash = NftAuctionProto.getRabinPubkeyHashArrayHash(preScript,slen);
      bytes sensibleId = NftAuctionProto.getSensibleID(preScript,slen);
      bytes codeHash = NftAuctionProto.getContractCodeHash(preScript,slen);

      bytes _senderAddress = NftAuctionProto.getSenderAddress(script,slen);
      int _startBsvPrice = Util.fromLEUnsigned(NftAuctionProto.getStartBsvPrice(script,slen));
      bytes _timeRabinPubKeyHash = NftAuctionProto.getTimeRabinPubkeyHash(script,slen);
      bytes _nftCodeHash = NftAuctionProto.getNftCodehash(script,slen);
      bytes _nftID = NftAuctionProto.getNftID(script,slen);
      int _endTimeStamp = Util.fromLEUnsigned(NftAuctionProto.getEndTimestamp(script,slen));
      bytes _rabinPubkeyHashArrayHash = NftAuctionProto.getRabinPubkeyHashArrayHash(script,slen);
      bytes _sensibleId = NftAuctionProto.getSensibleID(script,slen);
      bytes _codeHash = NftAuctionProto.getContractCodeHash(script,slen);

      require(
          senderAddress == _senderAddress && 
          startBsvPrice == _startBsvPrice && 
          timeRabinPubKeyHash == _timeRabinPubKeyHash && 
          nftCodeHash == _nftCodeHash && 
          nftID == _nftID && 
          endTimeStamp == _endTimeStamp &&
          rabinPubkeyHashArrayHash == _rabinPubkeyHashArrayHash &&
          sensibleId == _sensibleId &&
          codeHash == _codeHash
      );
      return true;
  }

  public function unlock(
    SigHashPreimage txPreimage,
    bytes nftScript,
    int nftOutputSatoshis,
    int preTimestamp,
    int preBsvBidPrice,
    Ripemd160 preBidder,
    Ripemd160 changeAddress,
    int changeSatoshis,
    bytes opReturnScript,
    bytes timeRabinMsg,
    bytes timeRabinSig,
    bytes timeRabinPadding,
    bytes timeRabinPubKey,

    bytes rabinMsg,
    bytes[RabinUtil.ORACLE_VERIFY_NUM] rabinPaddingArray,
    int[RabinUtil.ORACLE_VERIFY_NUM] rabinSigArray,
    int[RabinUtil.ORACLE_VERIFY_NUM] rabinPubKeyIndexArray,
    int[RabinUtil.ORACLE_VERIFY_NUM] rabinPubKeyVerifyArray,
    bytes rabinPubKeyHashArray,

    PubKey senderPubKey, // only cancel need
    Sig senderSig // only cancel need
  ) {
    SigHashType sigHashType = SigHash.ALL | SigHash.ANYONECANPAY | SigHash.FORKID;
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    bytes auctionScript = Util.scriptCode(txPreimage);
    int auctionScriptLen = len(auctionScript);

    require(hash160(timeRabinPubKey) == NftAuctionProto.getTimeRabinPubkeyHash(auctionScript,auctionScriptLen));
    int _timestamp = RabinUtil.getOracleTime(timeRabinMsg,timeRabinSig,timeRabinPadding,timeRabinPubKey);
    require(_timestamp > Util.fromLEUnsigned(NftAuctionProto.getEndTimestamp(auctionScript,auctionScriptLen)));

    bytes sensibleID = NftAuctionProto.getSensibleID(auctionScript, auctionScriptLen);

    bytes thisOutpoint = Util.outpoint(txPreimage);

    bytes rabinPubKeyHashArrayHash = NftAuctionProto.getRabinPubkeyHashArrayHash(auctionScript,auctionScriptLen);
    RabinUtil.verifyRabinPubKey(rabinPubKeyHashArrayHash,rabinPubKeyHashArray, rabinPubKeyVerifyArray, rabinPubKeyIndexArray);

    RabinUtil.verifyRabinMsg(rabinPubKeyVerifyArray, rabinMsg, rabinPaddingArray, rabinSigArray);

    PayloadU4SpendByData pl = RabinUtil.loadPayloadU4SpendBy(rabinMsg);
    bytes preAuctionScript = NftAuctionProto.getNewBidScript(auctionScript,auctionScriptLen,preTimestamp,preBsvBidPrice,preBidder,sensibleID);
    this.checkData(preAuctionScript,auctionScript,auctionScriptLen); 

    require(pl.byTxId == thisOutpoint[ : 32]);
    require(pl.outpoint==sensibleID || hash160(preAuctionScript) == pl.scriptHash);

    int nftScriptLen = len(nftScript);

    int lastBsvBidPrice = Util.fromLEUnsigned(NftAuctionProto.getBidBsvPrice(auctionScript, auctionScriptLen));
    bytes lastBidder = NftAuctionProto.getBidderAddress(auctionScript, auctionScriptLen);
    bytes senderAddress =  NftAuctionProto.getSenderAddress(auctionScript,auctionScriptLen);

    bytes outputs = b'';
    if (lastBidder == NftAuctionProto.NULL_ADDRESS){
      // check sig
      require(hash160(senderPubKey) == senderAddress);
      require(checkSig(senderSig, senderPubKey));
      
      bytes outputScript = NftProto.getNewNftScript(nftScript, nftScriptLen, senderAddress);
      outputs = Util.buildOutput(outputScript, nftOutputSatoshis);

    }else {
      bytes newNftScript = NftProto.getNewNftScript(nftScript, nftScriptLen, lastBidder);
      bytes nftOutput = Util.buildOutput(newNftScript, nftOutputSatoshis);

      bytes collectionScript = Util.buildPublicKeyHashScript(Ripemd160(senderAddress));
      bytes collectionOutput = Util.buildOutput(collectionScript, lastBsvBidPrice);
      outputs = nftOutput + collectionOutput;
    }

    bytes opReturnOutput = b'';
    if (len(opReturnScript) > 0) {
      require(opReturnScript[: 2] == b'006a');
      opReturnOutput = Util.buildOutput(opReturnScript, 0);
    }

    bytes changeOutput = b'';
    if (changeSatoshis > 0) {
      bytes changeScript = Util.buildPublicKeyHashScript(changeAddress);
      changeOutput = Util.buildOutput(changeScript, changeSatoshis);
    }

    bytes hashOutput = hash256(outputs + opReturnOutput + changeOutput);
    require(hashOutput == Util.hashOutputs(txPreimage));
  }

  public function bid(
    SigHashPreimage txPreimage,
    int bidTimestamp,
    int bsvBidPrice,
    Ripemd160 bidder,
    int preBidTimestamp,
    int preBsvBidPrice,
    Ripemd160 preBidder,
    Ripemd160 changeAddress,
    int changeSatoshis,
    bytes opReturnScript,
    bytes timeRabinMsg,
    bytes timeRabinSig,
    bytes timeRabinPadding,
    bytes timeRabinPubKey,

    bytes rabinMsg,
    bytes[RabinUtil.ORACLE_VERIFY_NUM] rabinPaddingArray,
    int[RabinUtil.ORACLE_VERIFY_NUM] rabinSigArray,
    int[RabinUtil.ORACLE_VERIFY_NUM] rabinPubKeyIndexArray,
    int[RabinUtil.ORACLE_VERIFY_NUM] rabinPubKeyVerifyArray,
    bytes rabinPubKeyHashArray
  ){
    SigHashType sigHashType = SigHash.ALL | SigHash.ANYONECANPAY | SigHash.FORKID;
    require(Util.checkPreimageSigHashType(txPreimage, sigHashType));

    bytes auctionScript = Util.scriptCode(txPreimage);
    int auctionScriptLen = len(auctionScript);

    require(hash160(timeRabinPubKey) == NftAuctionProto.getTimeRabinPubkeyHash(auctionScript,auctionScriptLen));

    int _timestamp = RabinUtil.getOracleTime(timeRabinMsg,timeRabinSig,timeRabinPadding,timeRabinPubKey);
    require(bidTimestamp == _timestamp);
    int endTimeStamp = Util.fromLEUnsigned(NftAuctionProto.getEndTimestamp(auctionScript,auctionScriptLen));
    int lastBidTimestamp = Util.fromLEUnsigned(NftAuctionProto.getBidTimestamp(auctionScript,auctionScriptLen));
    require(bidTimestamp < endTimeStamp);
    require(bidTimestamp > lastBidTimestamp);

    bytes sensibleID = NftAuctionProto.getSensibleID(auctionScript, auctionScriptLen);
    bytes bidderAddress = NftAuctionProto.getBidderAddress(auctionScript, auctionScriptLen);
    bool isFirst = false;
    if (bidderAddress == NftAuctionProto.NULL_ADDRESS) {
      isFirst = true;
    }
    require(NftAuctionProto.checkProtoHeader(auctionScript, auctionScriptLen));
    // check opreturn
    require(NftAuctionProto.checkDataLen(auctionScript, auctionScriptLen));
    require(NftAuctionProto.checkOpReturn(auctionScript, auctionScriptLen));

    bytes rabinPubKeyHashArrayHash = NftAuctionProto.getRabinPubkeyHashArrayHash(auctionScript,auctionScriptLen);
    RabinUtil.verifyRabinPubKey(rabinPubKeyHashArrayHash,rabinPubKeyHashArray, rabinPubKeyVerifyArray, rabinPubKeyIndexArray);

    RabinUtil.verifyRabinMsg(rabinPubKeyVerifyArray, rabinMsg, rabinPaddingArray, rabinSigArray);

    PayloadU4SpendByData pl = RabinUtil.loadPayloadU4SpendBy(rabinMsg);
    bytes thisOutpoint = Util.outpoint(txPreimage);
    bytes preAuctionScript = NftAuctionProto.getNewBidScript(auctionScript,auctionScriptLen,preBidTimestamp,preBsvBidPrice,preBidder,sensibleID);

    this.checkData(preAuctionScript,auctionScript,auctionScriptLen);
    require(pl.byTxId == thisOutpoint[ : 32]);
    require(pl.outpoint==sensibleID || hash160(preAuctionScript) == pl.scriptHash);

    bytes refunOutput = b'';
    if (!isFirst) {
      bytes lastBidder = NftAuctionProto.getBidderAddress(auctionScript, auctionScriptLen);
      int lastBidPrice = Util.fromLEUnsigned(NftAuctionProto.getBidBsvPrice(auctionScript, auctionScriptLen));
      require(bsvBidPrice > lastBidPrice);

      bytes refunOutputScript = Util.buildPublicKeyHashScript(Ripemd160(lastBidder));
      refunOutput = Util.buildOutput(refunOutputScript, lastBidPrice);
    }
    else {
      require(bsvBidPrice >= Util.fromLEUnsigned(NftAuctionProto.getStartBsvPrice(auctionScript,auctionScriptLen)));
    }
    bytes newAuctionScript = NftAuctionProto.getNewBidScript(auctionScript, auctionScriptLen,bidTimestamp, bsvBidPrice, bidder, sensibleID);
    bytes auctionOuput = Util.buildOutput(newAuctionScript, bsvBidPrice);

    bytes opReturnOutput = b'';
    if (len(opReturnScript) > 0) {
      require(opReturnScript[: 2] == b'006a');
      opReturnOutput = Util.buildOutput(opReturnScript, 0);
    }

    bytes changeOutput = b'';
    if (changeSatoshis > 0) {
      bytes changeScript = Util.buildPublicKeyHashScript(changeAddress);
      changeOutput = Util.buildOutput(changeScript, changeSatoshis);
    }

    bytes outputs = auctionOuput + refunOutput + opReturnOutput + changeOutput;
    bytes hashOutput = hash256(outputs);
    require(hashOutput == Util.hashOutputs(txPreimage));
  }
}